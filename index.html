<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ClipThing</title>
  <style>
    /* :root { 
      --gap: 12px; 
      --bg:#0b0d10; 
      --card:#141821; 
      --fg:#e6e8eb; 
      --muted:#9aa4af; 
      --accent:#4da3ff; 
    }
    * { 
      box-sizing: border-box; 
    } */
    :root {
      --bg: #0f0f0f;
      --fg: #ffffff;
      --accent: #ffa600;
      --cardbg: #202020;
      --cardfg: #ffffff;
    }
    body { 
      margin: 0; 
      font-family: system-ui, -apple-system, sans-serif; 
      background: var(--bg); 
      color: var(--fg); 
    }
    header { 
      padding: 14px 18px; 
      border-bottom: 1px solid #1e242f; 
      display: flex; 
      align-items: center; 
      gap: 12px; 
    }
    header h1 { 
      margin: 0; 
      font-size: 18px; 
      font-weight: 600; 
    }
    header .spacer{ 
      flex:1; 
    }
    main { 
      padding: 16px; 
    }
    .grid { 
      display: grid; 
      grid-template-columns: repeat(auto-fill, minmax(250px, 2fr)); 
      gap: 9px; 
    }
    .card {
      background: var(--cardbg); 
      color: var(--cardfg);
      border-radius: 12px; 
      overflow: hidden; 
      border: 1px solid #1e242f; 
      cursor: pointer; 
    }
    .thumb { 
      display: block;
      width: 100%;
      aspect-ratio: 16 / 9;
      object-fit: cover;
      background:#0d1117;
    }
    .meta { 
      padding: 10px;
      display: grid;
      gap: 6px;
    }
    .title { 
      font-size: 14px;
      font-weight: 600;
    }
    .sub { 
      font-size: 12px;
      color: var(--muted);
    }
    .controls { 
      display: flex;
      gap: 8px;
      align-items: center;
    }
    button, input, select { 
      background:#0f1320;
      color:var(--fg);
      border:1px solid #252c39;
      border-radius:8px;
      padding:8px 10px;
    }
    button.primary { 
      background: var(--accent);
      color:#001428;
      border:0;
    }
    .editor { 
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,.55);
      padding: 24px;
    }
    .editor.show { 
      display:flex;
    }
    .editorContent { 
      /* make panel responsive: limit max width and allow it to shrink on small screens */
      width: 100%;
      max-width: 100%;
      background:#0d1117;
      border-radius: 14px;
      overflow: scroll;
    }
    .editorContent header { 
      display:flex;
      align-items:center;
      gap:10px;
      border-bottom:1px solid #1e242f;
      padding:10px 12px;
    }
    .editorContent .body { 
      padding: 12px;
      display:grid;
      gap:12px;
    }
    .editorContent .closeBtn {
      background: var(--accent);
      color: #001428;
      font-size: 16px;
      cursor: pointer;
    }
    .editorContent .exportBtn {
      background: var(--accent);
      color:#001428;
      border:0;
    }
    /* video { width: 100%;
      background:black;
      border-radius: 8px;
    } */
    .videoPlayer { 
      /* responsive video: fill available width while keeping aspect ratio */
      display: block;
      width: 100%;
      height: auto;
      max-height: 60vh; /* don't exceed 60% of viewport height */
      background: black;
      border-radius: 8px;
    }

    /* ensure editor padding doesn't cause horizontal overflow on tiny screens */
    @media (max-width: 520px) {
      .editor { padding: 12px; }
      .panel { max-width: 100%; }
      .row { grid-template-columns: 1fr; }
      .sliders { grid-template-columns: repeat(2, 1fr); }
    }
    .row { 
      display:grid;
      gap:10px;
      grid-template-columns: 1fr 1fr;
    }
    .row .col { 
      background:#0f1320;
      border:1px solid #1f2633;
      border-radius:10px;
      padding:10px;
    }
    /* .sliders { 
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
    } */
    .prog { 
      height:10px;
      background:#1b2130;
      border-radius:6px;
      overflow:hidden;
    }
    .prog > div { 
      height:100%;
      width:0%;
      background:linear-gradient(90deg,#3bb3ff,#7ad3ff);
    }
    .muted { 
      color: var(--muted);
      font-size: 12px;
    }
  </style>
</head>

<body>
  <header>
    <h1>ClipThing</h1>
    <div class="spacer"></div>
    <div id="status">
      <button id="status">Status/Refresh</button>
    </div>
  </header>
  <main>
    <div id="grid" class="grid"></div>
  </main>

  <div id="editor" class="editor" role="dialog" aria-modal="true">
    <div class="editorContent">
      <header>
        <button id="deleteButton" class="closeBtn" title="Delete Clip" style="background:#ff4c4c;color:#fff;font-weight:bold">-</button>
        <div id="editorTitle" class="title" contenteditable="true">Clip</div>
        <div class="spacer"></div>
        <button class="closeBtn" id="closeBtn">X</button>
      </header>
      <div class="body">
        <video class="videoPlayer"id="player" controls></video>
          <div class="col">
            <div class="title">Trim</div>
            <div class="controls">
              <label>Start (s): <input id="start" type="number" min="0" step="0.1" value="0"></label>
              <button id="setStart">Use current</button>
            </div>
            <div class="controls">
              <label>End (s): <input id="end" type="number" min="0" step="0.1" value="0"></label>
              <button id="setEnd">Use current</button>
            </div>
            <div class="controls">
              <label>Size limit (MB): <input id="sizeLimit" type="number" min="5" step="1" value="50"></label>
            </div>
          </div>
          <button id="exportBtn" class="primary">
            Export
          </button>
          <div class="col" id="volumesDiv">
            <!-- <div class="controls"> -->
            <!-- <div class="prog" style="flex:1"><div id="progressBar"></div></div> -->
            </div>

          <button href="#" class="primary" style="display:inline">
            <a id="downloadLink" href="#">Download</a>
          </button>
          <div id="jobMsg" class="muted">
          </div>
      </div>
    </div>
  </div>

<script>
const grid = document.getElementById('grid');
const editor = document.getElementById('editor');
const player = document.getElementById('player');
const editorTitle = document.getElementById('editorTitle');
const startTS = document.getElementById('start');
const endTS = document.getElementById('end');
const sizeLimitEl = document.getElementById('sizeLimit');
// const progressBar = document.getElementById('progressBar');
const jobMsg = document.getElementById('jobMsg');
const downloadButton = document.getElementById('downloadLink');
const deleteButton = document.getElementById('deleteButton');


// const volumesDiv = document.getElementById('volumesDiv');

// we dont know how many audio tracks there will be 
// fetch them !!todo
// we now know, still fix it tho

let volumes = []; // store references to range inputs

let current = null; // current clip item

function fmtSec(second){
  return (Math.round(second*10)/10).toFixed(1); }

// human-friendly relative time formatter
function timeAgo(ts){
  if (!ts) return '??/??/????';
  // ts (this) meme is dead ðŸ’”ðŸ’”
  const then = new Date(ts * 1000);
  const now = new Date();
  const diff = Math.floor((now - then) / 1000); // seconds
  if (diff < 0) return 'just now';
  if (diff < 60) return diff === 1 ? '1 second ago' : `${diff} seconds ago`;
  const mins = Math.floor(diff / 60);
  if (mins < 60) return mins === 1 ? '1 minute ago' : `${mins} minutes ago`;
  const hours = Math.floor(mins / 60);
  if (hours < 24) return hours === 1 ? '1 hour ago' : `${hours} hours ago`;
  const days = Math.floor(hours / 24);
  if (days === 1) return 'yesterday';
  if (days < 7) return `${days} days ago`;
  const weeks = Math.floor(days / 7);
  if (weeks < 5) return weeks === 1 ? '1 week ago' : `${weeks} weeks ago`;
  // older than ~1 month -> show dd/mm/yyyy | anti american
  const d = then;
  const dd = String(d.getDate()).padStart(2, '0');
  const mm = String(d.getMonth() + 1).padStart(2, '0');
  const yyyy = d.getFullYear();
  return `${dd}/${mm}/${yyyy}`;
}

function formatSize(bytes) {
  if (bytes == null) return null;

  const units = ["B", "KB", "MB", "GB", "TB"];
  let i = 0;
  let size = bytes;

  while (size >= 1024 && i < units.length - 1) {
    size /= 1024;
    i++;
  }

  return Math.ceil(size) + " " + units[i];
}

async function fetchJSON(url, opts){
  const response = await fetch(url, opts);
  if (!response.ok) throw new Error(await response.text());
  return response.json();
}

async function loadClips() {
grid.innerHTML = '';
const clips = await fetchJSON('/clips');

for (const item of clips) {
  const card = document.createElement('div');
  card.className = 'card';

  // Use placeholder image initially
  const img = document.createElement('img');
  img.className = 'thumb';
  img.alt = 'thumbnail';
  img.src = '/loading.jpg'; // lightweight placeholder
  img.dataset.uuid = item.uuid;

  const meta = document.createElement('div');
  meta.className = 'meta';
  meta.innerHTML = `
    <div class="title">${item.edited_title || item.file}</div>
    <div class="sub">
      <h4>${item.size_bytes != null ? formatSize(item.size_bytes) : '??'}</h4>
      <h4>${timeAgo(item.creation_time)}</h4>
    </div>
  `;

  card.appendChild(img);
  card.appendChild(meta);
  card.addEventListener('click', () => openClip(item));
  grid.appendChild(card);

  observeImage(img); // Hook image into lazy loader
}
}

const observer = new IntersectionObserver((entries, observer) => {
  for (const entry of entries) {
    if (entry.isIntersecting) {
      const img = entry.target;
      const uuid = img.dataset.uuid;

      fetch(`/clips/${uuid}/thumb`)
        .then(resp => resp.ok ? resp.blob() : Promise.reject())
        .then(blob => {
          const url = URL.createObjectURL(blob);
          img.src = url;
        })
        .catch(() => {
          img.src = '/loading.jpg';
        });

      observer.unobserve(img); // Only load once
    }
  }
}, {
  rootMargin: '200px', // start loading slightly before visible
  threshold: 0.1
});

function observeImage(img) {
  observer.observe(img);
}

async function openClip(item){
  current = item;
  editorTitle.textContent = item.edited_title || item.file;

  
  // audio junk --------------  
  const audio_tracks = item.audio_tracks;
  volSlidersArray = Array.from({length: audio_tracks}, (_, i) => 1.0);

  const container = document.getElementById('volumesDiv');

  // clear previous sliders
  container.innerHTML = '';

  // Create the sliders dynamically
  volSlidersArray.forEach((value, index) => {
    const label = document.createElement('label');
    // label.textContent = `Slider ${index + 1}: `;

    const range = document.createElement('input');
    range.type = 'range';
    range.min = 0;
    range.max = 1.5;
    range.step = 0.05;
    range.value = value;
    range.id = `range-${index}`; // Unique ID

    const output = document.createElement('span');
    output.textContent = value;

    range.addEventListener('input', () => {
      output.textContent = range.value;
    });

    container.appendChild(label);
    container.appendChild(range);
    container.appendChild(output);
    container.appendChild(document.createElement('br'));
  });
  // audio junk --------------



  editor.classList.add('show');
  jobMsg.textContent = '';
  downloadButton.style.display = 'none'; // hide download button
  // bar.style.width = '0%';
  player.src = `/clips/${item.uuid}/play`;
  player.load();

  const clip = await fetchJSON(`/clips/${item.uuid}`, { method: 'GET' });

  startTS.value = clip.edited_start || 0;
  endTS.value = clip.edited_stop ? fmtSec(clip.edited_stop) : (clip.duration ? fmtSec(clip.duration) : '0');

};

function collectValues() {
      const newValues = [];

      volSlidersArray.forEach((_, index) => {
        const slider = document.getElementById(`range-${index}`);
        const value = parseFloat(slider.value);
        newValues.push(value);
      });
      // console.log("Collected slider values:", newValues);
      return newValues;
}

document.getElementById('setStart').onclick = async ()=>{
  startTS.value = fmtSec(player.currentTime || 0);

  await fetchJSON(`/clips/${current.uuid}`,
  {
    method:'PATCH',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify
    ({
      edited_start: startTS.value
    })
  });
};

document.getElementById('setEnd').onclick = async ()=>{
  // const d = player.duration || 0;
  const t = player.currentTime || 0;
  endTS.value = fmtSec(Math.max(t, 0.1));

  await fetchJSON(`/clips/${current.uuid}`,
  {
    method:'PATCH',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify
    ({
      edited_stop: endTS.value
    })
  });
};

deleteButton.onclick = async () => {
  if (!current) return;
  const confirmed = confirm(`Are you sure you want to delete the clip "${current.edited_title || current.file}" from disk?`); // TODO optional file delete
  if (!confirmed) return;

  try {
    await fetchJSON(`/clips/${current.uuid}`, { method: 'DELETE' });
    closeEditor();
    loadClips().catch(() => {});
  } catch (error) {
    alert('Failed to delete clip: ' + (error.message || error)); // TODO make it a notif, dont take up my whole screen
    console.error('Error deleting clip:', error);
  }
};


async function startExport(){
  if (!current) return;
  const start = parseFloat(startTS.value || '0');
  let end = parseFloat(endTS.value || '0');
  
  const d = player.duration || 0;
  if (!end || end <= start) end = d || (start + 1);


  const volumes = collectValues();
  console.log('Volumes going to API: ', volumes);


  const payload = {
    start, end, 
    volumes,
    size_limit_mb: parseFloat(sizeLimitEl.value || '50')
  };


  const res = await fetchJSON(`/clips/${current.uuid}/export`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
  jobMsg.textContent = 'Job Queued!';
  downloadButton.style.display = 'inline';
}


document.getElementById('exportBtn').onclick = ()=>{ 
  startExport().catch(e=> alert(e.message||e)); 
};

downloadButton.onclick = async (e) => {
  e.preventDefault();
  console.log('download clicked');
  console.log('current:', current);

  if (!current) {
    console.log('No current clip selected.');
    return;
  }

  const url = `/clips/${current.uuid}/export`;

  try {
    const response = await fetch(url, { method: 'HEAD' }); // check if it exists
    if (response.ok) {
      // file exists, go download
      const tempLink = document.createElement('a'); //make a temp link otherwise it loops the onClick
      tempLink.href = url;
      // we dont set the download name clientside bc the server already names the file w the edited title
      document.body.appendChild(tempLink);
      tempLink.click();
      document.body.removeChild(tempLink);
    } else {
      console.warn('File not ready:', response.status);
      downloadButton.textContent = 'not ready >:(';
      setTimeout(() => {
        downloadButton.textContent = 'Download';
      }, 500);
    }
  } catch (err) {
    console.error('Error checking file:', err);
    downloadButton.textContent = 'Error :(\nCheck console';
    setTimeout(() => {
      downloadButton.textContent = 'Download';
    }, 500);
  }
};



document.getElementById('status').onclick = ()=> loadClips().catch(()=>{});


// editor title change
editorTitle.addEventListener('input', async ()=>{
  console.log('title changed: ', editorTitle.textContent);
  await fetchJSON(`/clips/${current.uuid}`,
  {
    method:'PATCH',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify
    ({
      edited_title: editorTitle.textContent
    })
  });
});


async function closeEditor(){
  editor.classList.remove('show');
  player.pause();
  current = null;
}

document.getElementById('closeBtn').onclick = ()=>{
  closeEditor();
};

window.onclick = function(event) {
  if (event.target == editor) {
    closeEditor();
  }
};


// init
loadClips().catch(err=>{ grid.innerHTML = '<div class="muted">Failed to load clips</div>'; console.error(err); });


    
</script>
</body>
</html>
